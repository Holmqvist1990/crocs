{"lookups": {"Hash":{"lookup":{"new":[[".new(default_value : V, initial_capacity = nil)","Creates a new empty Hash where the default_value is returned if a key is missing."],[".new(ctx : YAML::ParseContext, node : YAML::Nodes::Node)"],[".new(pull : JSON::PullParser)","Reads a Hash from the given pull parser."],[".new(block : Hash(K, V), K -> V | Nil = nil, *, initial_capacity = nil)","Creates a new empty Hash with a block for handling missing keys."],[".new(ctx : YAML::ParseContext, node : YAML::Nodes::Node, &)"],[".new(initial_capacity = nil, &block : Hash(K, V), K -> V)","Creates a new empty Hash with a block that handles missing keys."]],"ne":[[".new","Creates a new empty Hash."]],"zip":[[".zip(ary1 : Array(K), ary2 : Array(V))","Zips two arrays into a Hash, taking keys from ary1 and values from ary2."]],"==":[["#==(other : Hash) : Bool","Compares with other."],["#==(other : JSON::Any)"],["#==(other : YAML::Any)"]],"[]":[["#[](key)","Returns the value for the key given by key."]],"[]=":[["#[]=(key : K, value : V) : V","Sets the value of key to the given value."]],"[]?":[["#[]?(key)","Returns the value for the key given by key."]],"clear":[["#clear : self","Empties a Hash and returns it."]],"clone":[["#clone : Hash(K, V)","Similar to #dup, but duplicates the values as well."]],"compac":[["#compact","Returns new Hash without nil values."]],"compact!":[["#compact! : self","Removes all nil value from self."]],"compare_by_identity":[["#compare_by_identity : self","Makes this hash compare keys using their object identity (object_id) for types that define such method (Reference types, but also structs that might wrap other Reference types and delegate the object_id method to them)."]],"compare_by_identity?":[["#compare_by_identity? : Bool","Returns true of this Hash is comparing keys by object_id."]],"delete":[["#delete(key) : V | Nil","Deletes the key-value pair and returns the value, otherwise returns nil."],["#delete(key, &)","Deletes the key-value pair and returns the value, else yields key with given block."]],"dig":[["#dig(key : K, *subkeys)","Traverses the depth of a structure and returns the value, otherwise raises KeyError."]],"dig?":[["#dig?(key : K, *subkeys)","Traverses the depth of a structure and returns the value."]],"dup":[["#dup : Hash(K, V)","Duplicates a Hash."]],"each":[["#each(& : Tuple(K, V) -> ) : Nil","Calls the given block for each key-value pair and passes in the key and the value."]],"eac":[["#each","Returns an iterator over the hash entries."]],"each_key":[["#each_key(& : K -> )","Calls the given block for each key-value pair and passes in the key."]],"each_ke":[["#each_key","Returns an iterator over the hash keys."]],"each_value":[["#each_value(& : V -> )","Calls the given block for each key-value pair and passes in the value."]],"each_valu":[["#each_value","Returns an iterator over the hash values."]],"empty?":[["#empty? : Bool","Returns true when hash contains no key-value pairs."]],"fetch":[["#fetch(key, default)","Returns the value for the key given by key, or when not found the value given by default."],["#fetch(key, &)","Returns the value for the key given by key, or when not found calls the given block with the key."]],"first_key":[["#first_key : K","Returns the first key in the hash."]],"first_key?":[["#first_key? : K | Nil","Returns the first key if it exists, or returns nil."]],"first_value":[["#first_value : V","Returns the first value in the hash."]],"first_value?":[["#first_value? : V | Nil","Returns the first value if it exists, or returns nil."]],"has_key?":[["#has_key?(key) : Bool","Returns true when key given by key exists, otherwise false."]],"has_value?":[["#has_value?(val) : Bool","Returns true when value given by value exists, otherwise false."]],"hash":[["#hash(hasher)","See Object#hash(hasher)"]],"inspect":[["#inspect(io : IO) : Nil","Appends a String representation of this object which includes its class name, its object address and the values of all instance variables."]],"invert":[["#invert : Hash(V, K)","Inverts keys and values."]],"key_for":[["#key_for(value) : K","Returns a key with the given value, else raises KeyError."],["#key_for(value, &)","Returns a key with the given value, else yields value with the given block."]],"key_for?":[["#key_for?(value) : K | Nil","Returns a key with the given value, else nil."]],"keys":[["#keys : Array(K)","Returns a new Array with all the keys."]],"last_key":[["#last_key : K","Returns the last key in the hash."]],"last_key?":[["#last_key? : K | Nil","Returns the last key if it exists, or returns nil."]],"last_value":[["#last_value : V","Returns the last value in the hash."]],"last_value?":[["#last_value? : V | Nil","Returns the last value if it exists, or returns nil."]],"merge":[["#merge(other : Hash(L, W)) : Hash(K | L, V | W) forall L, W","Returns a new Hash with the keys and values of this hash and other combined."],["#merge(other : Hash(L, W), & : L, V, W -> V | W) : Hash(K | L, V | W) forall L, W"]],"merge!":[["#merge!(other : Hash) : self","Similar to #merge, but the receiver is modified."],["#merge!(other : Hash, &) : self","Adds the contents of other to this hash."]],"pretty_print":[["#pretty_print(pp) : Nil"]],"proper_subset_of?":[["#proper_subset_of?(other : Hash) : Bool","Returns true if self is a subset of other."]],"proper_superset_of?":[["#proper_superset_of?(other : Hash) : Bool","Returns true if other is a subset of self or equals to self."]],"put":[["#put(key : K, value : V, &)","Sets the value of key to the given value."]],"rehash":[["#rehash : Nil","Rebuilds the hash table based on the current value of each key."]],"reject":[["#reject(& : K, V -> ) : Hash(K, V)","Returns a new hash consisting of entries for which the block is falsey."],["#reject(*keys) : Hash(K, V)","Returns a new Hash without the given keys."]],"reject!":[["#reject!(& : K, V -> _)","Equivalent to Hash#reject, but makes modification on the current object rather than returning a new one."],["#reject!(keys : Enumerable) : self","Removes a list of keys out of hash."],["#reject!(*keys) : self","Removes a list of keys out of hash."]],"select":[["#select(& : K, V -> ) : Hash(K, V)","Returns a new hash consisting of entries for which the block is truthy."],["#select(keys : Enumerable) : Hash(K, V)","Returns a new Hash with the given keys."],["#select(*keys) : Hash(K, V)","Returns a new Hash with the given keys."]],"select!":[["#select!(& : K, V -> ) : self","Equivalent to Hash#select but makes modification on the current object rather than returning a new one."],["#select!(keys : Indexable) : self","Removes every element except the given ones."],["#select!(keys : Enumerable) : self","Removes every element except the given ones."],["#select!(*keys) : self","Removes every element except the given ones."]],"shift":[["#shift : Tuple(K, V)","Deletes and returns the first key-value pair in the hash, or raises IndexError if the hash is empty."],["#shift(&)","Deletes and returns the first key-value pair in the hash."]],"shift?":[["#shift? : Tuple(K, V) | Nil","Same as #shift, but returns nil if the hash is empty."]],"size":[["#size : Int32","Returns the number of elements in this Hash."]],"subset_of?":[["#subset_of?(other : Hash) : Bool","Returns true if self is a subset of other or equals to other."]],"superset_of?":[["#superset_of?(other : Hash) : Bool","Returns true if other is a subset of self."]],"to_a":[["#to_a : Array(Tuple(K, V))","Returns an array of tuples with key and values belonging to this Hash."]],"to_h":[["#to_h : self","Returns self."]],"to_json":[["#to_json(json : JSON::Builder) : Nil","Serializes this Hash into JSON."]],"to_s":[["#to_s(io : IO) : Nil","Converts to a String."]],"to_yaml":[["#to_yaml(yaml : YAML::Nodes::Builder) : Nil"]],"transform_keys":[["#transform_keys(& : K -> K2) : Hash(K2, V) forall K2","Returns a new hash with all keys converted using the block operation."]],"transform_values":[["#transform_values(& : V -> V2) : Hash(K, V2) forall V2","Returns a new hash with the results of running block once for every value."]],"transform_values!":[["#transform_values!(& : V -> V) : self","Destructively transforms all values using a block."]],"update":[["#update(key : K, & : V -> V) : V","Updates the current value of key with the value returned by the given block (the current value is used as input for the block)."]],"values":[["#values : Array(V)","Returns only the values as an Array."]],"values_at":[["#values_at(*keys : K)","Returns a tuple populated with the values of the given keys, with the same order."]]}},"Time":{"lookup":{"local":[[".local(year : Int32, month : Int32, day : Int32, hour : Int32 = 0, minute : Int32 = 0, second : Int32 = 0, *, nanosecond : Int32 = 0, location : Location = Location.local) : Time","Creates a new Time instance representing the given local date-time in location (defaults to local time zone)."],[".local(location : Location = Location.local) : Time","Creates a new Time instance representing the current time from the system clock observed in location (defaults to local time zone)."]],"new":[[".new(ctx : YAML::ParseContext, node : YAML::Nodes::Node)"],[".new(pull : JSON::PullParser)","Reads a string from JSON parser as a time formatted according to RFC 3339 or other variations of ISO 8601."],[".new(*, seconds : Int64, nanoseconds : Int32, location : Location)","Creates a new Time instance that corresponds to the number of seconds and nanoseconds elapsed from epoch (0001-01-01 00:00:00.0 UTC) observed in location."]],"parse":[[".parse(time : String, pattern : String, location : Location) : Time","Parses a Time from time string using the given pattern."]],"parse!":[[".parse!(time : String, pattern : String) : Time","Parses a Time from time string using the given pattern."]],"parse_local":[[".parse_local(time : String, pattern : String) : Time","Parses a Time from time string using the given pattern and Time::Location.local as default location"]],"parse_rfc2822":[[".parse_rfc2822(time : String) : self","Parse time format specified by RFC 2822."]],"parse_rfc3339":[[".parse_rfc3339(time : String) : self","Parse time format specified by RFC 3339 (ISO 8601 profile)."]],"parse_utc":[[".parse_utc(time : String, pattern : String) : Time","Parses a Time from time string using the given pattern and Time::Location::UTC as default location."]],"unix":[[".unix(seconds : Int) : Time","Creates a new Time instance that corresponds to the number of seconds elapsed since the Unix epoch (1970-01-01 00:00:00 UTC)."]],"unix_ms":[[".unix_ms(milliseconds : Int) : Time","Creates a new Time instance that corresponds to the number of milliseconds elapsed since the Unix epoch (1970-01-01 00:00:00 UTC)."]],"utc":[[".utc(year : Int32, month : Int32, day : Int32, hour : Int32 = 0, minute : Int32 = 0, second : Int32 = 0, *, nanosecond : Int32 = 0) : Time","Creates a new Time instance representing the given date-time in UTC."],[".utc : Time","Creates a new Time instance representing the current time from the system clock in UTC."],[".utc(*, seconds : Int64, nanoseconds : Int32) : Time","Creates a new Time instance that corresponds to the number of seconds and nanoseconds elapsed from epoch (0001-01-01 00:00:00.0 UTC) in UTC."]],"week_date":[[".week_date(year : Int32, week : Int32, day_of_week : Int32 | DayOfWeek, hour : Int32 = 0, minute : Int32 = 0, second : Int32 = 0, *, nanosecond : Int32 = 0, location : Location = Location.local) : self","Creates an instance specified by a commercial week date consisting of ISO calendar year, week and a day_of_week."]],"days_in_month":[[".days_in_month(year : Int, month : Int) : Int32","Returns the number of days in month (value range: 1..12) taking account of the year."]],"days_in_year":[[".days_in_year(year : Int) : Int32","Returns the number of days in year."]],"leap_year?":[[".leap_year?(year : Int) : Bool","Returns true if year is a leap year in the proleptic Gregorian calendar."]],"measure":[[".measure(&) : Time::Span","Measures the execution time of block."]],"monotonic":[[".monotonic : Time::Span","Returns a reading from the monotonic clock to measure elapsed time."]],"parse_iso8601":[[".parse_iso8601(time : String)","Parse datetime format specified by ISO 8601."]],"+":[["#+(span : Time::Span) : Time","Returns a copy of this Time with span added."],["#+(span : Time::MonthSpan) : Time","Returns a copy of this Time with span added."]],"-":[["#-(other : Time) : Time::Span","Returns a Time::Span amounting to the duration between other and self."],["#-(span : Time::Span) : Time","Returns a copy of this Time with span subtracted."],["#-(span : Time::MonthSpan) : Time","Returns a copy of this Time with span subtracted."]],"<=>":[["#<=>(other : Time) : Int32","Compares this Time with other."]],"==":[["#==(other : Time) : Bool","Compares this Time with other for equality."]],"at_beginning_of_day":[["#at_beginning_of_day : Time","Returns a copy of this Time representing the beginning of the day."]],"at_beginning_of_hour":[["#at_beginning_of_hour : Time","Returns a copy of this Time representing the beginning of the hour."]],"at_beginning_of_minute":[["#at_beginning_of_minute : Time","Returns a copy of this Time representing the beginning of the minute."]],"at_beginning_of_month":[["#at_beginning_of_month : Time","Returns a copy of this Time representing the beginning of the month."]],"at_beginning_of_quarter":[["#at_beginning_of_quarter : Time","Returns a copy of this Time representing the beginning of the quarter."]],"at_beginning_of_second":[["#at_beginning_of_second : Time","Returns a copy of this Time representing the beginning of the seconds."]],"at_beginning_of_semester":[["#at_beginning_of_semester : Time","Returns a copy of this Time representing the beginning of the semester."]],"at_beginning_of_week":[["#at_beginning_of_week : Time","Returns a copy of this Time representing the beginning of the week."]],"at_beginning_of_year":[["#at_beginning_of_year : Time","Returns a copy of this Time representing the beginning of the year."]],"at_end_of_day":[["#at_end_of_day : Time","Returns a copy of this Time representing the end of the day."]],"at_end_of_hour":[["#at_end_of_hour : Time","Returns a copy of this Time representing the end of the hour."]],"at_end_of_minute":[["#at_end_of_minute : Time","Returns a copy of this Time representing the end of the minute."]],"at_end_of_month":[["#at_end_of_month : Time","Returns a copy of this Time representing the end of the month."]],"at_end_of_quarter":[["#at_end_of_quarter : Time","Returns a copy of this Time representing the end of the quarter."]],"at_end_of_second":[["#at_end_of_second : Time","Returns a copy of this Time representing the end of the second."]],"at_end_of_semester":[["#at_end_of_semester : Time","Returns a copy of this Time representing the end of the semester."]],"at_end_of_week":[["#at_end_of_week : Time","Returns a copy of this Time representing the end of the week."]],"at_end_of_year":[["#at_end_of_year : Time","Returns a copy of this Time representing the end of the year."]],"at_midday":[["#at_midday : Time","Returns a copy of this Time representing midday (12:00) of the same day."]],"calendar_week":[["#calendar_week : Tuple(Int32, Int32)","Returns the ISO calendar year and week in which this instance occurs."]],"clone":[["#clone : Time"]],"date":[["#date : Tuple(Int32, Int32, Int32)","Returns a Tuple with #year, #month and #day."]],"day":[["#day : Int32","Returns the day of the month (1..31)."]],"day_of_week":[["#day_of_week : Time::DayOfWeek","Returns the day of the week (Monday..Sunday)."]],"day_of_year":[["#day_of_year : Int32","Returns the day of the year."]],"friday?":[["#friday? : Bool","Returns true if the day of week is Friday."]],"hash":[["#hash(hasher)","See Object#hash(hasher)"]],"hour":[["#hour : Int32","Returns the hour of the day (0..23)."]],"in":[["#in(location : Location) : Time","Returns a copy of this Time representing the same instant observed in location."]],"inspect":[["#inspect(io : IO, with_nanoseconds = true) : Nil","Prints this Time to io."]],"local?":[["#local? : Bool","Returns true if #location equals to the local time zone (Time::Location.local)."]],"location":[["#location : Location","Returns Location representing the time-zone observed by this Time."]],"millisecond":[["#millisecond : Int32","Returns the millisecond of the second (0..999)."]],"minute":[["#minute : Int32","Returns the minute of the hour (0..59)."]],"monday?":[["#monday? : Bool","Returns true if the day of week is Monday."]],"month":[["#month : Int32","Returns the month of the year (1..12)."]],"nanosecond":[["#nanosecond : Int32","Returns the nanosecond of the second (0..999_999_999)."]],"offset":[["#offset : Int32","Returns the offset from UTC (in seconds) in effect in #location at this instant."]],"saturday?":[["#saturday? : Bool","Returns true if the day of week is Saturday."]],"second":[["#second : Int32","Returns the second of the minute (0..59)."]],"shift":[["#shift(seconds : Int, nanoseconds : Int) : Time","Returns a copy of this Time shifted by the number of seconds and nanoseconds."],["#shift(*, years : Int = 0, months : Int = 0, weeks : Int = 0, days : Int = 0, hours : Int = 0, minutes : Int = 0, seconds : Int = 0, nanoseconds : Int = 0)","Returns a copy of this Time shifted by the amount of calendaric units provided as arguments."]],"sunday?":[["#sunday? : Bool","Returns true if the day of week is Sunday."]],"thursday?":[["#thursday? : Bool","Returns true if the day of week is Thursday."]],"time_of_day":[["#time_of_day : Time::Span","Returns the duration between this Time and midnight of the same day."]],"to_json":[["#to_json(json : JSON::Builder) : Nil","Emits a string formatted according to RFC 3339 (ISO 8601 profile)."]],"to_local":[["#to_local : Time","Returns a copy of this Time representing the same instant in the local time zone (Time::Location.local)."]],"to_local_in":[["#to_local_in(location : Location) : Time","Creates a new Time instance with the same local date-time representation (wall clock) in a different location."]],"to_rfc2822":[["#to_rfc2822(io : IO)","Format this time using the format specified by RFC 2822 into the given io."],["#to_rfc2822 : String","Format this time using the format specified by RFC 2822."]],"to_rfc3339":[["#to_rfc3339(io : IO, *, fraction_digits : Int = 0) : Nil","Format this time using the format specified by RFC 3339 (ISO 8601 profile)."],["#to_rfc3339(*, fraction_digits : Int = 0)","Format this time using the format specified by RFC 3339 (ISO 8601 profile)."]],"to_s":[["#to_s(io : IO, format : String) : Nil","Formats this Time according to the pattern in format to the given io."],["#to_s(io : IO) : Nil","Prints this Time to io."],["#to_s(format : String) : String","Formats this Time according to the pattern in format."]],"to_unix":[["#to_unix : Int64","Returns the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)."]],"to_unix_f":[["#to_unix_f : Float64","Returns the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC) as Float64 with nanosecond precision."]],"to_unix_ms":[["#to_unix_ms : Int64","Returns the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)."]],"to_utc":[["#to_utc : Time","Returns a copy of this Time representing the same instant in UTC (Time::Location::UTC)."]],"to_yaml":[["#to_yaml(yaml : YAML::Nodes::Builder) : Nil"]],"tuesday?":[["#tuesday? : Bool","Returns true if the day of week is Tuesday."]],"utc?":[["#utc? : Bool","Returns true if #location equals to Location::UTC."]],"wednesday?":[["#wednesday? : Bool","Returns true if the day of week is Wednesday."]],"year":[["#year : Int32","Returns the year of the proleptic Georgian Calendar (0..9999)."]],"zone":[["#zone : Time::Location::Zone","Returns the time zone in effect in #location at this instant."]]}},"String":{"lookup":{"build":[[".build(capacity = 64, &) : self","Builds a String by creating a String::Builder with the given initial capacity, yielding it to the block and finally getting a String out of it."]],"from_json_object_key?":[[".from_json_object_key?(key : String) : String"]],"from_utf16":[[".from_utf16(slice : Slice(UInt16)) : String","Decodes the given slice UTF-16 sequence into a String."],[".from_utf16(pointer : Pointer(UInt16)) : Tuple(String, Pointer(UInt16))","Decodes the given slice UTF-16 sequence into a String and returns the pointer after reading."]],"interpolation":[[".interpolation(value : String, char : Char) : String","Implementation of string interpolation of a string and a char."],[".interpolation(char : Char, value : String) : String","Implementation of string interpolation of a char and a string."],[".interpolation(value : String) : String","Implementation of string interpolation of a single string."],[".interpolation(value) : String","Implementation of string interpolation of a single non-string value."],[".interpolation(*values : String) : String","Implementation of string interpolation of multiple string values."],[".interpolation(*values : *T) : String forall T","Implementation of string interpolation of multiple, possibly non-string values."]],"new":[[".new(bytes : Bytes, encoding : String, invalid : Symbol | Nil = nil) : String","Creates a new String from the given bytes, which are encoded in the given encoding."],[".new(chars : Pointer(UInt8), bytesize, size = 0)","Creates a new String from a pointer, indicating its bytesize count and, optionally, the UTF-8 codepoints count (size)."],[".new(ctx : YAML::ParseContext, node : YAML::Nodes::Node)"],[".new(chars : Pointer(UInt8))","Creates a String from a pointer."],[".new(slice : Bytes)","Creates a String from the given slice."],[".new(capacity : Int, &)","Creates a new String by allocating a buffer (Pointer(UInt8)) with the given capacity, then yielding that buffer."],[".new(pull : JSON::PullParser)"]],"%":[["#%(other) : String","Interpolates other into the string using top-level ::sprintf."]],"*":[["#*(times : Int) : String","Makes a new String by adding str to itself times times."]],"+":[["#+(other : self) : String","Concatenates str and other."],["#+(char : Char) : String","Concatenates str and other."]],"<=>":[["#<=>(other : self) : Int32","The comparison operator."]],"==":[["#==(other : self) : Bool","Returns true if this string is equal to `other."]],"=~":[["#=~(regex : Regex) : Int32 | Nil","Tests whether str matches regex."],["#=~(other) : Nil","Tests whether str matches regex."]],"[]":[["#[](start : Int, count : Int) : String","Returns a substring starting from the start character of size count."],["#[](regex : Regex, group) : String"],["#[](index : Int) : Char","Returns the Char at the given index."],["#[](range : Range) : String","Returns the substring indicated by range as span of character indices."],["#[](str : String | Char)","Returns str if str is found in this string."],["#[](regex : Regex) : String"]],"[]?":[["#[]?(start : Int, count : Int) : String | Nil","Like #[](Int, Int) but returns nil if the start index is out of bounds."],["#[]?(regex : Regex, group) : String | Nil"],["#[]?(range : Range) : String | Nil","Like #[](Range), but returns nil if range.begin is out of range."],["#[]?(index : Int) : Char | Nil","Returns the character at index or nil if it's out of range."],["#[]?(str : String | Char)","Returns str if str is found in this string, or nil otherwise."],["#[]?(regex : Regex) : String | Nil"]],"ascii_only?":[["#ascii_only? : Bool","Returns true if this String is comprised in its entirety by ASCII characters."]],"blank?":[["#blank? : Bool","Returns true if this string consists exclusively of unicode whitespace."]],"byte_at":[["#byte_at(index) : UInt8","Returns the byte at the given index."],["#byte_at(index, &)","Returns the byte at the given index, or yields if out of bounds."]],"byte_at?":[["#byte_at?(index) : UInt8 | Nil","Returns the byte at the given index, or nil if out of bounds."]],"byte_index":[["#byte_index(byte : Int, offset = 0) : Int32 | Nil","Returns the index of the first occurrence of byte in the string, or nil if not present."],["#byte_index(search : String, offset = 0) : Int32 | Nil","Returns the byte index of search in the string, or nil if the string is not present."]],"byte_index_to_char_index":[["#byte_index_to_char_index(index) : Int32 | Nil","Returns the char index of a byte index, or nil if out of bounds."]],"byte_slice":[["#byte_slice(start : Int, count : Int) : String","Returns a new string built from count bytes starting at start byte."],["#byte_slice(range : Range) : String","Returns a new string built from byte in range."],["#byte_slice(start : Int) : String","Returns a substring starting from the start byte."]],"byte_slice?":[["#byte_slice?(start : Int, count : Int) : String | Nil","Like #byte_slice(Int, Int) but returns Nil if the start index is out of bounds."],["#byte_slice?(range : Range) : String | Nil","Like #byte_slice(Range) but returns Nil if range begin is out of bounds."],["#byte_slice?(start : Int) : String | Nil","Returns a substring starting from the start byte."]],"bytes":[["#bytes : Array(UInt8)","Returns this string's bytes as an Array(UInt8)."]],"bytesize":[["#bytesize : Int32","Returns the number of bytes in this string."]],"camelcase":[["#camelcase(io : IO, options : Unicode::CaseOptions = Unicode::CaseOptions::None, *, lower : Bool = false) : Nil","Writes an camelcased version of self to the given io."],["#camelcase(options : Unicode::CaseOptions = Unicode::CaseOptions::None, *, lower : Bool = false) : String","Converts underscores to camelcase boundaries."]],"capitalize":[["#capitalize(options : Unicode::CaseOptions = :none) : String","Returns a new String with the first letter converted to uppercase and every subsequent letter converted to lowercase."],["#capitalize(io : IO, options : Unicode::CaseOptions = :none) : Nil","Writes a capitalized version of self to the given io."]],"center":[["#center(len : Int, char : Char = ' ') : String","Adds instances of char to left and right of the string until it is at least size of len."],["#center(io : IO, len : Int, char : Char = ' ') : Nil","Adds instances of char to left and right of the string until it is at least size of len, then appends the result to the given IO."]],"char_at":[["#char_at(index : Int) : Char","Returns the Char at the given index."],["#char_at(index : Int, &)","Returns the Char at the given index, or result of running the given block if out of bounds."]],"char_index_to_byte_index":[["#char_index_to_byte_index(index)","Returns the byte index of a char index, or nil if out of bounds."]],"chars":[["#chars : Array(Char)","Returns an Array of all characters in the string."]],"check_no_null_byte":[["#check_no_null_byte(name = nil) : self","Raises an ArgumentError if self has null bytes."]],"chomp":[["#chomp(suffix : Char) : String","Returns a new String with suffix removed from the end of the string."],["#chomp(suffix : String) : String","Returns a new String with suffix removed from the end of the string."],["#chomp : String","Returns a new String with the last carriage return removed (that is, it will remove \\n, \\r, and \\r\\n)."]],"clone":[["#clone : String","Returns self."]],"codepoint_at":[["#codepoint_at(index) : Int32","Returns the codepoint of the character at the given index."]],"codepoints":[["#codepoints : Array(Int32)","Returns an Array of the codepoints that make the string."]],"compare":[["#compare(other : String, case_insensitive = false, options : Unicode::CaseOptions = :none) : Int32","Compares this string with other, returning -1, 0 or 1 depending on whether this string is less, equal or greater than other, optionally in a case_insensitive manner."]],"count":[["#count(&) : Int32","Yields each char in this string to the block, returns the number of times the block returned a truthy value."],["#count(other : Char) : Int32","Counts the occurrences of other char in this string."],["#count(*sets) : Int32","Sets should be a list of strings following the rules described at Char#in_set?."]],"delete":[["#delete(&) : String","Yields each char in this string to the block."],["#delete(char : Char) : String","Returns a new String with all occurrences of char removed."],["#delete(*sets) : String","Sets should be a list of strings following the rules described at Char#in_set?."]],"delete_at":[["#delete_at(start : Int, count : Int) : String","Returns a new string that results from deleting count characters starting at start."],["#delete_at(range : Range) : String","Returns a new string that results from deleting characters at the given range."],["#delete_at(index : Int) : String","Returns a new string that results from deleting the character at the given index."],["#delete_at(*, index start : Int, count : Int) : String","Returns a new string that results from deleting count characters starting at start.","DEPRECATED  Use #delete_at(start, count) instead"]],"downcase":[["#downcase(options : Unicode::CaseOptions = :none) : String","Returns a new String with each uppercase letter replaced with its lowercase counterpart."],["#downcase(io : IO, options : Unicode::CaseOptions = :none) : Nil","Writes a downcased version of self to the given io."]],"dump":[["#dump(io : IO) : Nil","Returns a representation of self as an ASCII-compatible Crystal string literal, wrapped in double quotes."],["#dump : String","Returns a representation of self as an ASCII-compatible Crystal string literal, wrapped in double quotes."]],"dump_unquoted":[["#dump_unquoted : String","Returns a representation of self as the content of an ASCII-compatible Crystal string literal without delimiters."]],"dup":[["#dup : String","Returns self."]],"each_byte":[["#each_byte(&)","Yields each byte in the string to the block."]],"each_byt":[["#each_byte","Returns an Iterator over each byte in the string."]],"each_char":[["#each_char(&) : Nil","Yields each character in the string to the block."]],"each_cha":[["#each_char","Returns an Iterator over each character in the string."]],"each_char_with_index":[["#each_char_with_index(offset = 0, &)","Yields each character and its index in the string to the block."]],"each_codepoint":[["#each_codepoint(&)","Yields each codepoint to the block."]],"each_codepoin":[["#each_codepoint","Returns an Iterator for each codepoint."]],"each_grapheme":[["#each_grapheme(& : Grapheme -> _) : Nil","Yields each Unicode extended grapheme cluster in this string.","EXPERIMENTAL  The grapheme API is still under development. Join the discussion at #11610."],["#each_grapheme : Iterator(Grapheme)","Returns an iterator of this string split into Unicode extended grapheme clusters.","EXPERIMENTAL  The grapheme API is still under development. Join the discussion at #11610."]],"each_line":[["#each_line(chomp = true, &block : String -> ) : Nil","Splits the string after each newline and yields each line to a block."],["#each_line(chomp = true)","Returns an Iterator which yields each line of this string (see String#each_line)."]],"empty?":[["#empty? : Bool","Returns true if this is the empty string, \"\"."]],"encode":[["#encode(encoding : String, invalid : Symbol | Nil = nil) : Bytes","Returns a slice of bytes containing this string encoded in the given encoding."]],"ends_with?":[["#ends_with?(str : String) : Bool","Returns true if this string ends with the given str."],["#ends_with?(char : Char) : Bool","Returns true if this string ends with the given char."],["#ends_with?(re : Regex) : Bool","Returns true if the regular expression re matches at the end of this string."]],"grapheme_size":[["#grapheme_size : Int32","Returns the number of Unicode extended graphemes clusters in this string.","EXPERIMENTAL  The grapheme API is still under development. Join the discussion at #11610."]],"graphemes":[["#graphemes : Array(Grapheme)","Returns this string split into Unicode extended grapheme clusters.","EXPERIMENTAL  The grapheme API is still under development. Join the discussion at #11610."]],"gsub":[["#gsub(pattern : Regex, &) : String","Returns a String where all occurrences of the given pattern are replaced by the block value's value."],["#gsub(string : String, &) : String","Returns a String where all occurrences of the given string are replaced with the block's value."],["#gsub(&block : Char -> _) : String","Returns a String where each character yielded to the given block is replaced by the block's return value."],["#gsub(char : Char, replacement) : String","Returns a String where all occurrences of the given char are replaced with the given replacement."],["#gsub(pattern : Regex, hash : Hash(String, _) | NamedTuple) : String","Returns a String where all occurrences of the given pattern are replaced with a hash of replacements."],["#gsub(pattern : Regex, replacement, backreferences = true) : String","Returns a String where all occurrences of the given pattern are replaced with the given replacement."],["#gsub(string : String, replacement) : String","Returns a String where all occurrences of the given string are replaced with the given replacement."],["#gsub(hash : Hash(Char, _)) : String","Returns a String where all chars in the given hash are replaced by the corresponding hash values."],["#gsub(tuple : NamedTuple) : String","Returns a String where all chars in the given named tuple are replaced by the corresponding tuple values."]],"has_back_references":[["#has_back_references?","This returns true if this string has '\\\\' in it."]],"hash":[["#hash(hasher)","See Object#hash(hasher)"]],"hexbytes":[["#hexbytes : Bytes","Interprets this string as containing a sequence of hexadecimal values and decodes it as a slice of bytes."]],"hexbytes?":[["#hexbytes? : Bytes | Nil","Interprets this string as containing a sequence of hexadecimal values and decodes it as a slice of bytes."]],"includes?":[["#includes?(search : Char | String) : Bool","Returns true if the string contains search."]],"index":[["#index(search : Char, offset = 0) : Int32 | Nil","Returns the index of the first occurrence of search in the string, or nil if not present."],["#index(search : String, offset = 0)","Returns the index of the first occurrence of search in the string, or nil if not present."],["#index(search : Regex, offset = 0) : Int32 | Nil","Returns the index of the first occurrence of search in the string, or nil if not present."]],"index!":[["#index!(search, offset = 0) : Int32","Returns the index of the first occurrence of search in the string, or nil if not present."]],"insert":[["#insert(index : Int, other : Char) : String","Returns a new String that results of inserting other in self at index."],["#insert(index : Int, other : String) : String","Returns a new String that results of inserting other in self at index."]],"inspect":[["#inspect(io : IO) : Nil","Returns a representation of self as a Crystal string literal, wrapped in double quotes."],["#inspect : String","Returns a representation of self as a Crystal string literal, wrapped in double quotes."]],"inspect_unquoted":[["#inspect_unquoted(io : IO) : Nil","Returns a representation of self as the content of a Crystal string literal without delimiters."],["#inspect_unquoted : String","Returns a representation of self as the content of a Crystal string literal without delimiters."]],"lchop":[["#lchop(prefix : Char | String) : String","Returns a new String with prefix removed from the beginning of the string."],["#lchop : String","Returns a new String with the first char removed from it."]],"lchop?":[["#lchop?(prefix : Char | String) : String | Nil","Returns a new String with prefix removed from the beginning of the string if possible, else returns nil."],["#lchop? : String | Nil","Returns a new String with the first char removed from it if possible, else returns nil."]],"lines":[["#lines(chomp = true) : Array(String)"]],"ljust":[["#ljust(len : Int, char : Char = ' ') : String","Adds instances of char to right of the string until it is at least size of len."],["#ljust(io : IO, len : Int, char : Char = ' ') : Nil","Adds instances of char to right of the string until it is at least size of len, and then appends the result to the given IO."]],"lstrip":[["#lstrip(char : Char) : String","Returns a new string with leading occurrences of char removed."],["#lstrip(chars : String) : String","Returns a new string where leading occurrences of any char in chars are removed."],["#lstrip : String","Returns a new String with leading whitespace removed."],["#lstrip(&block : Char -> _) : String","Returns a new string where leading characters for which the block returns a truthy value are removed."]],"match":[["#match(regex : Regex, pos = 0) : Regex::MatchData | Nil","Finds match of regex, starting at pos."]],"matches?":[["#matches?(regex : Regex, pos = 0) : Bool","Finds match of regex like #match, but it returns Bool value."]],"partition":[["#partition(search : Char | String) : Tuple(String, String, String)","Searches separator or pattern (Regex) in the string, and returns a Tuple with the part before it, the match, and the part after it."],["#partition(search : Regex) : Tuple(String, String, String)","Searches separator or pattern (Regex) in the string, and returns a Tuple with the part before it, the match, and the part after it."]],"presence":[["#presence : self | Nil","Returns self unless #blank? is true in which case it returns nil."]],"pretty_print":[["#pretty_print(pp : PrettyPrint) : Nil","Pretty prints self into the given printer."]],"rchop":[["#rchop(suffix : Char | String) : String","Returns a new String with suffix removed from the end of the string."],["#rchop : String","Returns a new String with the last character removed."]],"rchop?":[["#rchop?(suffix : Char | String) : String | Nil","Returns a new String with suffix removed from the end of the string if possible, else returns nil."],["#rchop? : String | Nil","Returns a new String with the last character removed if possible, else returns nil."]],"reverse":[["#reverse : String","Reverses the order of characters in the string."]],"rindex":[["#rindex(search : Char, offset = size - 1)","Returns the index of the last appearance of search in the string, If offset is present, it defines the position to end the search (characters beyond this point are ignored)."],["#rindex(search : String, offset = size - search.size) : Int32 | Nil","Returns the index of the last appearance of search in the string, If offset is present, it defines the position to end the search (characters beyond this point are ignored)."],["#rindex(search : Regex, offset = size) : Int32 | Nil","Returns the index of the last appearance of search in the string, If offset is present, it defines the position to end the search (characters beyond this point are ignored)."]],"rindex!":[["#rindex!(search : Regex, offset = size) : Int32","Returns the index of the last appearance of search in the string, If offset is present, it defines the position to end the search (characters beyond this point are ignored)."],["#rindex!(search : String, offset = size - search.size) : Int32","Returns the index of the last appearance of search in the string, If offset is present, it defines the position to end the search (characters beyond this point are ignored)."],["#rindex!(search : Char, offset = size - 1) : Int32","Returns the index of the last appearance of search in the string, If offset is present, it defines the position to end the search (characters beyond this point are ignored)."]],"rjust":[["#rjust(len : Int, char : Char = ' ') : String","Adds instances of char to left of the string until it is at least size of len."],["#rjust(io : IO, len : Int, char : Char = ' ') : Nil","Adds instances of char to left of the string until it is at least size of len, and then appends the result to the given IO."]],"rpartition":[["#rpartition(search : Char | String) : Tuple(String, String, String)","Searches separator or pattern (Regex) in the string from the end of the string, and returns a Tuple with the part before it, the match, and the part after it."],["#rpartition(search : Regex) : Tuple(String, String, String)","Searches separator or pattern (Regex) in the string from the end of the string, and returns a Tuple with the part before it, the match, and the part after it."]],"rstrip":[["#rstrip(char : Char) : String","Returns a new string with trailing occurrences of char removed."],["#rstrip(chars : String) : String","Returns a new string where trailing occurrences of any char in chars are removed."],["#rstrip : String","Returns a new String with trailing whitespace removed."],["#rstrip(&block : Char -> _) : String","Returns a new string where trailing characters for which the block returns a truthy value are removed."]],"scan":[["#scan(pattern : Regex, &) : self","Searches the string for instances of pattern, yielding a Regex::MatchData for each match."],["#scan(pattern : Regex) : Array(Regex::MatchData)","Searches the string for instances of pattern, returning an Array of Regex::MatchData for each match."],["#scan(pattern : String, &) : self","Searches the string for instances of pattern, yielding the matched string for each match."],["#scan(pattern : String) : Array(String)","Searches the string for instances of pattern, returning an array of the matched string for each match."]],"scrub":[["#scrub(replacement = Char::REPLACEMENT) : String","Returns a String where bytes that are invalid in the UTF-8 encoding are replaced with replacement."]],"size":[["#size : Int32","Returns the number of unicode codepoints in this string."]],"split":[["#split(limit : Int32 | Nil = nil) : Array(String)","Makes an array by splitting the string on any amount of ASCII whitespace characters (and removing that whitespace)."],["#split(limit : Int32 | Nil = nil, &block : String -> _)","Splits the string after any amount of ASCII whitespace characters and yields each non-whitespace part to a block."],["#split(separator : Char, limit = nil, *, remove_empty = false) : Array(String)","Makes an Array by splitting the string on the given character separator (and removing that character)."],["#split(separator : Char, limit = nil, *, remove_empty = false, &block : String -> _)","Splits the string after each character separator and yields each part to a block."],["#split(separator : String, limit = nil, *, remove_empty = false) : Array(String)","Makes an Array by splitting the string on separator (and removing instances of separator)."],["#split(separator : String, limit = nil, *, remove_empty = false, &block : String -> _)","Splits the string after each string separator and yields each part to a block."],["#split(separator : Regex, limit = nil, *, remove_empty = false) : Array(String)","Makes an Array by splitting the string on separator (and removing instances of separator)."],["#split(separator : Regex, limit = nil, *, remove_empty = false, &block : String -> _)","Splits the string after each regex separator and yields each part to a block."]],"squeeze":[["#squeeze(&) : String","Yields each char in this string to the block."],["#squeeze(char : Char) : String","Returns a new String, with all runs of char replaced by one instance."],["#squeeze : String","Returns a new String, that has all characters removed, that were the same as the previous one."],["#squeeze(*sets : String) : String","Sets should be a list of strings following the rules described at Char#in_set?."]],"starts_with?":[["#starts_with?(str : String) : Bool","Returns true if this string starts with the given str."],["#starts_with?(char : Char) : Bool","Returns true if this string starts with the given char."],["#starts_with?(re : Regex) : Bool","Returns true if the regular expression re matches at the start of this string."]],"strip":[["#strip(char : Char) : String","Returns a new string where leading and trailing occurrences of char are removed."],["#strip(chars : String) : String","Returns a new string where leading and trailing occurrences of any char in chars are removed."],["#strip : String","Returns a new String with leading and trailing whitespace removed."],["#strip(&block : Char -> _) : String","Returns a new string where leading and trailing characters for which the block returns a truthy value are removed."]],"sub":[["#sub(pattern : Regex, &) : String","Returns a String where the first occurrence of pattern is replaced by the block's return value."],["#sub(string : String, &) : String","Returns a String where the first occurrences of the given string is replaced with the block's value."],["#sub(&block : Char -> _) : String","Returns a new String where the first character is yielded to the given block and replaced by its return value."],["#sub(char : Char, replacement) : String","Returns a String where the first occurrence of char is replaced by replacement."],["#sub(pattern : Regex, hash : Hash(String, _) | NamedTuple) : String","Returns a String where the first occurrences of the given pattern is replaced with the matching entry from the hash of replacements."],["#sub(pattern : Regex, replacement, backreferences = true) : String","Returns a String where the first occurrence of pattern is replaced by replacement"],["#sub(string : String, replacement) : String","Returns a String where the first occurrences of the given string is replaced with the given replacement."],["#sub(index : Int, replacement : Char) : String","Returns a new String with the character at the given index replaced by replacement."],["#sub(index : Int, replacement : String) : String","Returns a new String with the character at the given index replaced by replacement."],["#sub(range : Range, replacement : Char) : String","Returns a new String with characters at the given range replaced by replacement."],["#sub(range : Range, replacement : String) : String","Returns a new String with characters at the given range replaced by replacement."],["#sub(hash : Hash(Char, _)) : String","Returns a String where the first char in the string matching a key in the given hash is replaced by the corresponding hash value."]],"succ":[["#succ : String","Returns the successor of the string."]],"titleize":[["#titleize(options : Unicode::CaseOptions = :none) : String","Returns a new String with the first letter after any space converted to uppercase and every other letter converted to lowercase."],["#titleize(io : IO, options : Unicode::CaseOptions = :none) : Nil","Writes a titleized version of self to the given io."]],"to_big_d":[["#to_big_d : BigDecimal","Converts self to BigDecimal."]],"to_big_f":[["#to_big_f : BigFloat","Converts self to a BigFloat."]],"to_big_i":[["#to_big_i(base = 10) : BigInt","Returns a BigInt from this string, in the given base."]],"to_f":[["#to_f(whitespace : Bool = true, strict : Bool = true) : Float64","Returns the result of interpreting characters in this string as a floating point number (Float64)."]],"to_f32":[["#to_f32(whitespace : Bool = true, strict : Bool = true) : Float32","Same as #to_f but returns a Float32."]],"to_f32?":[["#to_f32?(whitespace : Bool = true, strict : Bool = true) : Float32 | Nil","Same as #to_f? but returns a Float32."]],"to_f64":[["#to_f64(whitespace : Bool = true, strict : Bool = true) : Float64","Returns the result of interpreting characters in this string as a floating point number (Float64)."]],"to_f64?":[["#to_f64?(whitespace : Bool = true, strict : Bool = true) : Float64 | Nil","Returns the result of interpreting characters in this string as a floating point number (Float64)."]],"to_f?":[["#to_f?(whitespace : Bool = true, strict : Bool = true) : Float64 | Nil","Returns the result of interpreting characters in this string as a floating point number (Float64)."]],"to_i":[["#to_i(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false)","Returns the result of interpreting leading characters in this string as an integer base base (between 2 and 36)."],["#to_i(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i, but returns the block's value if there is not a valid number at the start of this string, or if the resulting integer doesn't fit an Int32."]],"to_i128":[["#to_i128(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int128","Same as #to_i but returns an Int128."],["#to_i128(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an Int128 or the block's value."]],"to_i128?":[["#to_i128?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int128 | Nil","Same as #to_i but returns an Int128 or nil."]],"to_i16":[["#to_i16(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int16","Same as #to_i but returns an Int16."],["#to_i16(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an Int16 or the block's value."]],"to_i16?":[["#to_i16?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int16 | Nil","Same as #to_i but returns an Int16 or nil."]],"to_i32":[["#to_i32(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int32","Same as #to_i."],["#to_i32(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i."]],"to_i32?":[["#to_i32?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int32 | Nil","Same as #to_i."]],"to_i64":[["#to_i64(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int64","Same as #to_i but returns an Int64."],["#to_i64(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an Int64 or the block's value."]],"to_i64?":[["#to_i64?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int64 | Nil","Same as #to_i but returns an Int64 or nil."]],"to_i8":[["#to_i8(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int8","Same as #to_i but returns an Int8."],["#to_i8(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an Int8 or the block's value."]],"to_i8?":[["#to_i8?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : Int8 | Nil","Same as #to_i but returns an Int8 or nil."]],"to_i?":[["#to_i?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false)","Same as #to_i, but returns nil if there is not a valid number at the start of this string, or if the resulting integer doesn't fit an Int32."]],"to_json":[["#to_json(json : JSON::Builder) : Nil"]],"to_json_object_key":[["#to_json_object_key : String"]],"to_s":[["#to_s(io : IO) : Nil","Appends self to io."],["#to_s : String","Returns self."]],"to_slice":[["#to_slice : Bytes","Returns the underlying bytes of this String."]],"to_u128":[["#to_u128(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt128","Same as #to_i but returns an UInt128."],["#to_u128(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an UInt128 or the block's value."]],"to_u128?":[["#to_u128?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt128 | Nil","Same as #to_i but returns an UInt128 or nil."]],"to_u16":[["#to_u16(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt16","Same as #to_i but returns an UInt16."],["#to_u16(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an UInt16 or the block's value."]],"to_u16?":[["#to_u16?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt16 | Nil","Same as #to_i but returns an UInt16 or nil."]],"to_u32":[["#to_u32(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt32","Same as #to_i but returns an UInt32."],["#to_u32(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an UInt32 or the block's value."]],"to_u32?":[["#to_u32?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt32 | Nil","Same as #to_i but returns an UInt32 or nil."]],"to_u64":[["#to_u64(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt64","Same as #to_i but returns an UInt64."],["#to_u64(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an UInt64 or the block's value."]],"to_u64?":[["#to_u64?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt64 | Nil","Same as #to_i but returns an UInt64 or nil."]],"to_u8":[["#to_u8(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt8","Same as #to_i but returns an UInt8."],["#to_u8(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false, &)","Same as #to_i but returns an UInt8 or the block's value."]],"to_u8?":[["#to_u8?(base : Int = 10, whitespace : Bool = true, underscore : Bool = false, prefix : Bool = false, strict : Bool = true, leading_zero_is_octal : Bool = false) : UInt8 | Nil","Same as #to_i but returns an UInt8 or nil."]],"to_unsafe":[["#to_unsafe : Pointer(UInt8)","Returns a pointer to the underlying bytes of this String."]],"to_utf16":[["#to_utf16 : Slice(UInt16)","Returns the UTF-16 encoding of the given string."]],"to_yaml":[["#to_yaml(yaml : YAML::Nodes::Builder) : Nil"]],"tr":[["#tr(from : String, to : String) : String","Returns a new string _tr_anslating characters using from and to as a map."]],"underscore":[["#underscore(options : Unicode::CaseOptions = :none) : String","Converts camelcase boundaries to underscores."],["#underscore(io : IO, options : Unicode::CaseOptions = :none) : Nil","Writes an underscored version of self to the given io."]],"unicode_normalize":[["#unicode_normalize(form : Unicode::NormalizationForm = :nfc) : String","Returns the result of normalizing this String according to the given Unicode normalization form."],["#unicode_normalize(io : IO, form : Unicode::NormalizationForm = :nfc) : Nil","Normalizes this String according to the given Unicode normalization form and writes the result to the given io."]],"unicode_normalized?":[["#unicode_normalized?(form : Unicode::NormalizationForm = :nfc) : Bool","Returns whether this String is in the given Unicode normalization form."]],"unsafe_byte_at":[["#unsafe_byte_at(index : Int) : UInt8","Returns the byte at the given index without bounds checking.","DEPRECATED  Use to_unsafe[index] instead."]],"unsafe_byte_slice":[["#unsafe_byte_slice(byte_offset, count) : Slice","Returns count of underlying bytes of this String starting at given byte_offset."],["#unsafe_byte_slice(byte_offset) : Slice","Returns the underlying bytes of this String starting at given byte_offset."]],"upcase":[["#upcase(options : Unicode::CaseOptions = :none) : String","Returns a new String with each lowercase letter replaced with its uppercase counterpart."],["#upcase(io : IO, options : Unicode::CaseOptions = :none) : Nil","Writes a upcased version of self to the given io."]],"valid_encoding?":[["#valid_encoding? : Bool","Returns true if this String is encoded correctly according to the UTF-8 encoding."]]}},"Enumerable":{"lookup":{"element_type":[[".element_type(x)","Returns a value with the same type as an element of x, even if x is not an Enumerable."]],"accumulate":[["#accumulate(initial : U) : Array(U) forall U","Returns an array containing initial and its prefix sums with the elements in this collection."],["#accumulate : Array(T)","Returns an array of the prefix sums of the elements in this collection."],["#accumulate(initial : U, &block : U, T -> U) : Array(U) forall U","Returns an array containing initial and the successive values of applying a binary operation, specified by the given block, to this collection's elements."],["#accumulate(&block : T, T -> T) : Array(T)","Returns an array containing the successive values of applying a binary operation, specified by the given block, to this collection's elements."]],"all?":[["#all?(& : T -> ) : Bool","Returns true if the passed block is truthy for all elements of the collection."],["#all?(pattern) : Bool","Returns true if pattern === element for all elements in this enumerable."],["#all? : Bool","Returns true if all of the elements of the collection are truthy."]],"any?":[["#any?(& : T -> ) : Bool","Returns true if the passed block is truthy for at least one element of the collection."],["#any?(pattern) : Bool","Returns true if pattern === element for at least one element in this enumerable."],["#any? : Bool","Returns true if at least one of the collection's members is truthy."]],"chunks":[["#chunks(&block : T -> U) forall U","Enumerates over the items, chunking them together based on the return value of the block."]],"compact_map":[["#compact_map(& : T -> _)","Returns an Array with the results of running the block against each element of the collection, removing nil values."]],"count":[["#count(& : T -> ) : Int32","Returns the number of elements in the collection for which the passed block is truthy."],["#count(item) : Int32","Returns the number of times that the passed item is present in the collection."]],"cycle":[["#cycle(n, & : T -> ) : Nil","Calls the given block for each element in this enumerable n times."],["#cycle(& : T -> ) : Nil","Calls the given block for each element in this enumerable forever."]],"each":[["#each(& : T -> )","Must yield this collection's elements to the block."]],"each_cons":[["#each_cons(count : Int, reuse = false, &)","Iterates over the collection yielding chunks of size count, but advancing one by one."]],"each_cons_pair":[["#each_cons_pair(& : T, T -> ) : Nil","Iterates over the collection yielding pairs of adjacent items, but advancing one by one."]],"each_slice":[["#each_slice(count : Int, reuse = false, &)","Iterates over the collection in slices of size count, and runs the block for each of those."]],"each_with_index":[["#each_with_index(offset = 0, &)","Iterates over the collection, yielding both the elements and their index."]],"each_with_object":[["#each_with_object(obj : U, & : T, U -> ) : U forall U","Iterates over the collection, passing each element and the initial object obj."]],"empty?":[["#empty? : Bool","Returns true if self is empty, false otherwise."]],"find":[["#find(if_none = nil, & : T -> )","Returns the first element in the collection for which the passed block is truthy."]],"find!":[["#find!(& : T -> ) : T","Returns the first element in the collection for which the passed block is truthy."]],"first":[["#first(&)","Returns the first element in the collection, If the collection is empty, calls the block and returns its value."],["#first(count : Int) : Array(T)","Returns an Array with the first count elements in the collection."],["#first : T","Returns the first element in the collection."]],"first?":[["#first? : T | Nil","Returns the first element in the collection."]],"flat_map":[["#flat_map(& : T -> _)","Returns a new array with the concatenated results of running the block once for every element in the collection."]],"group_by":[["#group_by(& : T -> U) forall U","Returns a Hash whose keys are each different value that the passed block returned when run for each element in the collection, and which values are an Array of the elements for which the block returned that value."]],"in_groups_of":[["#in_groups_of(size : Int, filled_up_with : U = nil) forall U","Returns an Array with chunks in the given size, eventually filled up with given value or nil."],["#in_groups_of(size : Int, filled_up_with : U = nil, reuse = false, &) forall U","Yields a block with the chunks in the given size."]],"includes?":[["#includes?(obj) : Bool","Returns true if the collection contains obj, false otherwise."]],"index":[["#index(& : T -> ) : Int32 | Nil","Returns the index of the first element for which the passed block is truthy."],["#index(obj) : Int32 | Nil","Returns the first index of obj in the collection."]],"index!":[["#index!(& : T -> ) : Int32","Returns the index of the first element for which the passed block is truthy."],["#index!(obj) : Int32","Returns the first index of obj in the collection."]],"index_by":[["#index_by(& : T -> U) : Hash(U, T) forall U","Converts an Enumerable to a Hash by using the value returned by the block as the hash key."]],"join":[["#join(io : IO, separator = \"\") : Nil","Prints to io all the elements in the collection, separated by separator."],["#join(separator, io : IO) : Nil","Prints to io all the elements in the collection, separated by separator.","DEPRECATED  Use #join(io : IO, separator = \"\") instead"],["#join(separator = \"\") : String","Returns a String created by concatenating the elements in the collection, separated by separator (defaults to none)."],["#join(io : IO, separator = \"\", & : T, IO -> )","Prints to io the concatenation of the elements, with the possibility of controlling how the printing is done via a block."],["#join(separator, io : IO, &)","Prints to io the concatenation of the elements, with the possibility of controlling how the printing is done via a block.","DEPRECATED  Use #join(io : IO, separator = \"\", & : T, IO ->) instead"],["#join(separator = \"\", & : T -> )","Returns a String created by concatenating the results of passing the elements in the collection to the passed block, separated by separator (defaults to none)."]],"map":[["#map(& : T -> U) : Array(U) forall U","Returns an Array with the results of running the block against each element of the collection."]],"map_with_index":[["#map_with_index(offset = 0, & : T, Int32 -> U) : Array(U) forall U","Like #map, but the block gets passed both the element and its index."]],"max":[["#max : T","Returns the element with the maximum value in the collection."]],"max?":[["#max? : T | Nil","Like #max but returns nil if the collection is empty."]],"max_by":[["#max_by(& : T -> U) : T forall U","Returns the element for which the passed block returns with the maximum value."]],"max_by?":[["#max_by?(& : T -> U) : T | Nil forall U","Like #max_by but returns nil if the collection is empty."]],"max_of":[["#max_of(& : T -> U) : U forall U","Like #max_by but instead of the element, returns the value returned by the block."]],"max_of?":[["#max_of?(& : T -> U) : U | Nil forall U","Like #max_of but returns nil if the collection is empty."]],"min":[["#min : T","Returns the element with the minimum value in the collection."]],"min?":[["#min? : T | Nil","Like #min but returns nil if the collection is empty."]],"min_by":[["#min_by(& : T -> U) : T forall U","Returns the element for which the passed block returns with the minimum value."]],"min_by?":[["#min_by?(& : T -> U) : T | Nil forall U","Like #min_by but returns nil if the collection is empty."]],"min_of":[["#min_of(& : T -> U) : U forall U","Like #min_by but instead of the element, returns the value returned by the block."]],"min_of?":[["#min_of?(& : T -> U) : U | Nil forall U","Like #min_of but returns nil if the collection is empty."]],"minmax":[["#minmax : Tuple(T, T)","Returns a Tuple with both the minimum and maximum value."]],"minmax?":[["#minmax? : Tuple(T | Nil, T | Nil)","Like #minmax but returns {nil, nil} if the collection is empty."]],"minmax_by":[["#minmax_by(& : T -> U) : Tuple(T, T) forall U","Returns a Tuple with both the minimum and maximum values according to the passed block."]],"minmax_by?":[["#minmax_by?(& : T -> U) : Tuple(T, T) | Tuple(Nil, Nil) forall U","Like #minmax_by but returns {nil, nil} if the collection is empty."]],"minmax_of":[["#minmax_of(& : T -> U) : Tuple(U, U) forall U","Returns a Tuple with both the minimum and maximum value the block returns when passed the elements in the collection."]],"minmax_of?":[["#minmax_of?(& : T -> U) : Tuple(U, U) | Tuple(Nil, Nil) forall U","Like #minmax_of but returns {nil, nil} if the collection is empty."]],"none?":[["#none?(& : T -> ) : Bool","Returns true if the passed block is truthy for none of the elements of the collection."],["#none?(pattern) : Bool","Returns true if pattern === element for no element in this enumerable."],["#none? : Bool","Returns true if all of the elements of the collection are falsey."]],"one?":[["#one?(& : T -> ) : Bool","Returns true if the passed block is truthy for exactly one of the elements of the collection."],["#one?(pattern) : Bool","Returns true if pattern === element for just one element in this enumerable."],["#one? : Bool","Returns true if only one element in this enumerable is truthy."]],"partition":[["#partition(& : T -> ) : Tuple(Array(T), Array(T))","Returns a Tuple with two arrays."]],"product":[["#product(initial : Number)","Multiplies initial and all the elements in the collection together."],["#product(initial : Number, & : T -> )","Multiplies initial and all results of the passed block for each element in the collection."],["#product(& : T -> _)","Multiplies all results of the passed block for each element in the collection."]],"produc":[["#product","Multiplies all the elements in the collection together."]],"reduce":[["#reduce(memo, &)","Just like the other variant, but you can set the initial value of the accumulator."],["#reduce(&)","Combines all elements in the collection by applying a binary operation, specified by a block, so as to reduce them to a single value."]],"reduce?":[["#reduce?(&)","Similar to #reduce, but instead of raising when the input is empty, return nil"]],"reject":[["#reject(& : T -> )","Returns an Array with all the elements in the collection for which the passed block is falsey."],["#reject(type : U.class) forall U","Returns an Array with all the elements in the collection that are not of the given type."],["#reject(pattern) : Array(T)","Returns an Array with all the elements in the collection for which pattern === element is false."]],"sample":[["#sample(n : Int, random : Random = Random::DEFAULT) : Array(T)","Returns an Array of n random elements from self, using the given random number generator."],["#sample(random : Random = Random::DEFAULT) : T","Returns a random element from self, using the given random number generator."]],"select":[["#select(& : T -> )","Returns an Array with all the elements in the collection for which the passed block is truthy."],["#select(type : U.class) : Array(U) forall U","Returns an Array with all the elements in the collection that are of the given type."],["#select(pattern) : Array(T)","Returns an Array with all the elements in the collection for which pattern === element."]],"size":[["#size : Int32","Returns the number of elements in the collection."]],"skip":[["#skip(count : Int)","Returns an Array with the first count elements removed from the original collection."]],"skip_while":[["#skip_while(& : T -> ) : Array(T)","Skips elements up to, but not including, the first element for which the block is falsey, and returns an Array containing the remaining elements."]],"sum":[["#sum(initial)","Adds initial and all the elements in the collection together."],["#sum(initial, & : T -> )","Adds initial and all results of the passed block for each element in the collection."],["#sum(& : T -> )","Adds all results of the passed block for each element in the collection."]],"su":[["#sum","Adds all the elements in the collection together."]],"take_while":[["#take_while(& : T -> ) : Array(T)","Passes elements to the block until the block returns a falsey value, then stops iterating and returns an Array of all prior elements."]],"tally":[["#tally(hash)","Tallies the collection."],["#tally : Hash(T, Int32)","Tallies the collection."]],"tally_by":[["#tally_by(hash, &)","Tallies the collection."],["#tally_by(&block : T -> U) : Hash(U, Int32) forall U","Tallies the collection."]],"to_":[["#to_a","Returns an Array with all the elements in the collection."],["#to_h","Creates a Hash out of an Enumerable where each element is a 2 element structure (for instance a Tuple or an Array)."]],"to_h":[["#to_h(& : T -> Tuple(K, V)) forall K, V","Creates a Hash out of Tuple pairs (key, value) returned from the block."]],"to_set":[["#to_set : Set(T)","Returns a new Set with each unique element in the enumerable."]],"zip":[["#zip(*others : Indexable | Iterable | Iterator, &)","Yields elements of self and others in tandem to the given block."],["#zip(*others : Indexable | Iterable | Iterator)","Returns an Array of tuples populated with the elements of self and others traversed in tandem."]],"zip?":[["#zip?(*others : Indexable | Iterable | Iterator, &)","Yields elements of self and others in tandem to the given block."],["#zip?(*others : Indexable | Iterable | Iterator)","Returns an Array of tuples populated with the elements of self and others traversed in tandem."]]}}}}